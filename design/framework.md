# 前言
本篇幅先介绍传统的代码发布系统的做法,引申出传统做法的不足,然后介绍CodePub的架构,优势和解决的问题.

# 传统的CI发布架构
传统的CI发布系统有很多,典型的老牌代表是Jenkins,过去很长一段时间内它独立风骚,并不代表它完美,  
首先它的发布机制:核心是ssh协议  

发布代码的时候:  
- 1.拉取代码到jenkins的服务器上,
- 2.然后对比发版前后的变化的文件
- 3.把这些文件通过ssh协议顺序的推送到N个linux服务器节点上.

正是由于它的这种架构,决定了很多问题是无法避免的,比如:  
- 1.首先它是顺序推送,也就是总时间是随着节点数量直线增加的.
- 2.基于ssh协议,建立连接需要很久的时间.
- 3.由于是很多部门共用的系统,如果使用率很高,那么频繁的大量的本地拉取操作会导致服务器io延迟明显增大,导致系统反应过慢,影响稳定性.
- 4.即使很少量的文件变动,它还是拉去->对比->ssh推送,这个流程本身就很消耗时间.
- 5.java程序的诟病,占用内存严重,和windows一样用久了不重启就变慢.
- 6.非linux系统是无法发布代码的,比如windows是没有ssh的.

# CodePub架构
由于上面的诟病,是时候出来一个新的高效架构取代上面的传统模式了.

首先基于`管理中心/agent`的架构,这种架构决定了可以快速的通信,管理中心只负责发送指令给agent,然后agent执行具体操作.
如果是N个agent节点,管理中心是并发的发送指令,这样无论多少agent节点,发布的时间是不会变长的.
下面重点说一下agent执行git操作的过程,首先指令里面发送的主要是要发布的:branch\tag\commit_id这三个东西的一种.

agent收到指令后会:
- 1.首先fetch远程代码.
- 2.根据发布的`branch\tag\commit_id`获取要发布的最终commit_id,
- 3.然后`最终commit_id`在本地新建一个auto开头的分支,并检出`强制`这个分支,`强制意味着所有的本地修改都会被清除`,然后删除本地其它分支.
可以看到agent进行的是纯git操作,效率是很高的,对比ssh的方式时间上不是一个量级的.  
